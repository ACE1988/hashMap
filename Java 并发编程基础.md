## 为什么要使用多线程
1. 更多的处理器核心，线程是大多数操作系统调度的基本单元，一个程序作为一个进程来运行，程序运行过程中能过创建多个线程，而一个线程在一个时刻只能运行在一个处理器核心上。试想下，一个单线程程序在运行时只能使用一个处理器核心，那么再多的处理器核心加入也无法显著提升该程序的执行效率。相反如果该程序使用多线程技术，将计算逻辑分配到多个处理器核心上，就会显著减少程序的处理时间，并且随着更多处理器核心的加入而变得更有小路
2. 更快的效应时间，将数据一致性不强的操作派发给其他线程处理（也可以使用消息队列）。让响应用户请求的线程能够尽可能快的处理完成，缩短响应时间，提升用户体验。
3. 更好的编程模型，Java为多线程编程提供了良好，考究并且一致的编程模型，使开发人员能够更快专注于问题的解决，即为所遇到的问题简历合适的模型，而不是绞尽脑汁地考虑如何将其多线程化。


## 线程状态
线程状态：
. NEW：初始状态，线程被构建，但是还没有调用start()方法。
. RUNNABLE : 运行状态，Java线程将操作系统中的就绪和运行两种状态笼统地称作“运行中”
. BLOCKED ：阻塞状态，表示线程阻塞于锁
. WAITING : 等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一个特定动作（通知或中断）
. TIME_WAITING: 超时等待状态，该状态不同于WAITING，它是可以在指定的时间内自行返回的
. TERMINATED: 终止状态，表示当前线程以执行完毕

线程创建之后，调用start()方法开始运行，当线程执行wait()方法之后，线程进入等待状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而超时等待状态相当于在等待状态的基础上增加了超时限制，也就是在超时时间到达时将返回运行状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到阻塞状态。线程在执行Runnable的run()方法之后将会进入到终止状态.

备注
调用start（）后，线程会被放到等待队列，等待CPU调度，并不一定要马上开始执行，只是将这个线程置于可动行状态。然后通过JVM，线程Thread会调用run（）方法，执行本线程的线程体。先调用start后调用run，这么麻烦，为了不直接调用run？就是为了实现多线程的优点，没这个start不行。


1. start（）方法来启动线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码；通过调用Thread类的start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行操作的， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。

2. run（）方法当作普通方法的方式调用。程序还是要顺序执行，要等待run方法体执行完毕后，才可继续执行下面的代码； 程序中只有主线程——这一个线程， 其程序执行路径还是只有一条， 这样就没有达到写线程的目的。
